{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sessions } from \"../data/sessions\";\nimport { useEffect, useState } from \"react\";\nconst API_BASE = typeof window !== \"undefined\" && window.API_BASE || process.env.REACT_APP_API_BASE || \"http://localhost:8000\";\nconst getAuthHeader = () => {\n  try {\n    const t = localStorage.getItem('auth_token_fallback') || localStorage.getItem('token');\n    return t ? {\n      Authorization: `Bearer ${t}`\n    } : {};\n  } catch (e) {\n    return {};\n  }\n};\nexport function useCurrentSession(activeThreadId) {\n  _s();\n  const [session, setSession] = useState(null);\n  useEffect(() => {\n    let mounted = true;\n    if (!activeThreadId) {\n      setSession(null);\n      return;\n    }\n\n    // helper to fetch the server session; also used by the ai_user_changed listener\n    const fetchSession = async () => {\n      try {\n        const uid = typeof window !== \"undefined\" ? localStorage.getItem(\"user_id\") : null;\n        if (!uid || uid.startsWith(\"anon_\")) {\n          // leave as null for anonymous users\n          setSession(null);\n          return;\n        }\n        const resp = await fetch(`${API_BASE}/messages/${encodeURIComponent(uid)}/${encodeURIComponent(activeThreadId)}`, {\n          credentials: 'include',\n          headers: {\n            ...getAuthHeader()\n          }\n        });\n        if (!mounted) return;\n        if (!resp.ok) {\n          // fallback to local static sessions if backend unavailable\n          const s = [...sessions].filter(s => s.thread_id === activeThreadId).sort((a, b) => a.start_time < b.start_time ? 1 : -1)[0];\n          setSession(s !== null && s !== void 0 ? s : null);\n          return;\n        }\n        const data = await resp.json();\n        const msgs = data.messages || [];\n        const mapped = {\n          session_id: activeThreadId,\n          thread_id: activeThreadId,\n          start_time: new Date().toISOString(),\n          detected_mode: 'reflective',\n          confidence_score: 0.5,\n          messages: msgs.map(m => ({\n            role: m.role === 'assistant' ? 'assistant' : 'user',\n            content: m.content,\n            timestamp: m.ts || m.created_at\n          }))\n        };\n        setSession(mapped);\n      } catch (e) {\n        const s = [...sessions].filter(s => s.thread_id === activeThreadId).sort((a, b) => a.start_time < b.start_time ? 1 : -1)[0];\n        setSession(s !== null && s !== void 0 ? s : null);\n      }\n    };\n\n    // initial fetch\n    void fetchSession();\n\n    // Also re-fetch when user changes (e.g., after login/sign-in)\n    const handleUserChanged = () => {\n      void fetchSession();\n    };\n    if (typeof window !== 'undefined') window.addEventListener('ai_user_changed', handleUserChanged);\n    return () => {\n      mounted = false;\n      if (typeof window !== 'undefined') window.removeEventListener('ai_user_changed', handleUserChanged);\n    };\n  }, [activeThreadId]);\n  return {\n    session\n  };\n}\n_s(useCurrentSession, \"my2JknXsLNPscnT9b+5uRmb6O9A=\");","map":{"version":3,"names":["sessions","useEffect","useState","API_BASE","window","process","env","REACT_APP_API_BASE","getAuthHeader","t","localStorage","getItem","Authorization","e","useCurrentSession","activeThreadId","_s","session","setSession","mounted","fetchSession","uid","startsWith","resp","fetch","encodeURIComponent","credentials","headers","ok","s","filter","thread_id","sort","a","b","start_time","data","json","msgs","messages","mapped","session_id","Date","toISOString","detected_mode","confidence_score","map","m","role","content","timestamp","ts","created_at","handleUserChanged","addEventListener","removeEventListener"],"sources":["/Users/ankurporwal/Documents/PersonalManagementAgent/Frontend/src/hooks/useCurrentSession.ts"],"sourcesContent":["import { sessions } from \"../data/sessions\";\nimport { Session } from \"../types/thinking\";\nimport { useEffect, useState } from \"react\";\n\nconst API_BASE = (typeof window !== \"undefined\" && (window as any).API_BASE) || (process.env.REACT_APP_API_BASE as string) || \"http://localhost:8000\";\nconst getAuthHeader = () => {\n  try { const t = localStorage.getItem('auth_token_fallback') || localStorage.getItem('token'); return t ? { Authorization: `Bearer ${t}` } : {}; } catch (e) { return {}; }\n};\n\nexport function useCurrentSession(activeThreadId?: string) {\n  const [session, setSession] = useState<Session | null>(null);\n\n  useEffect(() => {\n    let mounted = true;\n    if (!activeThreadId) {\n      setSession(null);\n      return;\n    }\n\n    // helper to fetch the server session; also used by the ai_user_changed listener\n    const fetchSession = async () => {\n      try {\n        const uid = typeof window !== \"undefined\" ? localStorage.getItem(\"user_id\") : null;\n        if (!uid || uid.startsWith(\"anon_\")) {\n          // leave as null for anonymous users\n          setSession(null);\n          return;\n        }\n\n        const resp = await fetch(`${API_BASE}/messages/${encodeURIComponent(uid)}/${encodeURIComponent(activeThreadId)}`, { credentials: 'include', headers: { ...(getAuthHeader()) } });\n        if (!mounted) return;\n        if (!resp.ok) {\n          // fallback to local static sessions if backend unavailable\n          const s: Session | undefined = [...sessions]\n            .filter((s) => s.thread_id === activeThreadId)\n            .sort((a, b) => (a.start_time < b.start_time ? 1 : -1))[0];\n          setSession(s ?? null);\n          return;\n        }\n        const data = await resp.json();\n        const msgs = data.messages || [];\n        const mapped: Session = {\n          session_id: activeThreadId,\n          thread_id: activeThreadId,\n          start_time: new Date().toISOString(),\n          detected_mode: 'reflective',\n          confidence_score: 0.5,\n          messages: msgs.map((m: any) => ({ role: m.role === 'assistant' ? 'assistant' : 'user', content: m.content, timestamp: m.ts || m.created_at })),\n        };\n        setSession(mapped);\n      } catch (e) {\n        const s: Session | undefined = [...sessions]\n          .filter((s) => s.thread_id === activeThreadId)\n          .sort((a, b) => (a.start_time < b.start_time ? 1 : -1))[0];\n        setSession(s ?? null);\n      }\n    };\n\n    // initial fetch\n    void fetchSession();\n\n    // Also re-fetch when user changes (e.g., after login/sign-in)\n    const handleUserChanged = () => {\n      void fetchSession();\n    };\n    if (typeof window !== 'undefined') window.addEventListener('ai_user_changed', handleUserChanged as EventListener);\n\n    return () => { mounted = false; if (typeof window !== 'undefined') window.removeEventListener('ai_user_changed', handleUserChanged as EventListener); };\n  }, [activeThreadId]);\n\n  return { session };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}