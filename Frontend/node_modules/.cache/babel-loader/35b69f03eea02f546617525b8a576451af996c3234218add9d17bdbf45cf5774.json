{"ast":null,"code":"var _s = $RefreshSig$();\nimport { sessions } from \"../data/sessions\";\nimport { useEffect, useState } from \"react\";\nconst API_BASE = typeof window !== \"undefined\" && window.API_BASE || process.env.REACT_APP_API_BASE || \"http://localhost:8000\";\nexport function useCurrentSession(activeThreadId) {\n  _s();\n  const [session, setSession] = useState(null);\n  useEffect(() => {\n    let mounted = true;\n    if (!activeThreadId) {\n      setSession(null);\n      return;\n    }\n\n    // If anonymous, don't fetch server sessions\n    try {\n      const uid = typeof window !== \"undefined\" ? localStorage.getItem(\"user_id\") : null;\n      if (!uid || uid.startsWith(\"anon_\")) {\n        // leave as null for anonymous users\n        setSession(null);\n        return;\n      }\n\n      // fetch messages for this user/thread from backend\n      (async () => {\n        try {\n          const uid = localStorage.getItem(\"user_id\");\n          const resp = await fetch(`${API_BASE}/messages/${encodeURIComponent(uid)}/${encodeURIComponent(activeThreadId)}`);\n          if (!mounted) return;\n          if (!resp.ok) {\n            // fallback to local static sessions if backend unavailable\n            const s = [...sessions].filter(s => s.thread_id === activeThreadId).sort((a, b) => a.start_time < b.start_time ? 1 : -1)[0];\n            setSession(s !== null && s !== void 0 ? s : null);\n            return;\n          }\n          const data = await resp.json();\n          const msgs = data.messages || [];\n          const mapped = {\n            session_id: activeThreadId,\n            thread_id: activeThreadId,\n            start_time: new Date().toISOString(),\n            detected_mode: 'reflective',\n            confidence_score: 0.5,\n            messages: msgs.map(m => ({\n              role: m.role === 'assistant' ? 'assistant' : 'user',\n              content: m.content,\n              timestamp: m.ts || m.created_at\n            }))\n          };\n          setSession(mapped);\n        } catch (e) {\n          const s = [...sessions].filter(s => s.thread_id === activeThreadId).sort((a, b) => a.start_time < b.start_time ? 1 : -1)[0];\n          setSession(s !== null && s !== void 0 ? s : null);\n        }\n      })();\n    } catch (e) {\n      setSession(null);\n    }\n    return () => {\n      mounted = false;\n    };\n  }, [activeThreadId]);\n  return {\n    session\n  };\n}\n_s(useCurrentSession, \"my2JknXsLNPscnT9b+5uRmb6O9A=\");","map":{"version":3,"names":["sessions","useEffect","useState","API_BASE","window","process","env","REACT_APP_API_BASE","useCurrentSession","activeThreadId","_s","session","setSession","mounted","uid","localStorage","getItem","startsWith","resp","fetch","encodeURIComponent","ok","s","filter","thread_id","sort","a","b","start_time","data","json","msgs","messages","mapped","session_id","Date","toISOString","detected_mode","confidence_score","map","m","role","content","timestamp","ts","created_at","e"],"sources":["/Users/ankurporwal/Documents/AIConsultation/Frontend/src/hooks/useCurrentSession.ts"],"sourcesContent":["import { sessions } from \"../data/sessions\";\nimport { Session } from \"../types/thinking\";\nimport { useEffect, useState } from \"react\";\n\nconst API_BASE = (typeof window !== \"undefined\" && (window as any).API_BASE) || (process.env.REACT_APP_API_BASE as string) || \"http://localhost:8000\";\n\nexport function useCurrentSession(activeThreadId?: string) {\n  const [session, setSession] = useState<Session | null>(null);\n\n  useEffect(() => {\n    let mounted = true;\n    if (!activeThreadId) {\n      setSession(null);\n      return;\n    }\n\n    // If anonymous, don't fetch server sessions\n    try {\n      const uid = typeof window !== \"undefined\" ? localStorage.getItem(\"user_id\") : null;\n      if (!uid || uid.startsWith(\"anon_\")) {\n        // leave as null for anonymous users\n        setSession(null);\n        return;\n      }\n\n      // fetch messages for this user/thread from backend\n      (async () => {\n        try {\n          const uid = localStorage.getItem(\"user_id\")!;\n          const resp = await fetch(`${API_BASE}/messages/${encodeURIComponent(uid)}/${encodeURIComponent(activeThreadId)}`);\n          if (!mounted) return;\n          if (!resp.ok) {\n            // fallback to local static sessions if backend unavailable\n            const s: Session | undefined = [...sessions]\n              .filter((s) => s.thread_id === activeThreadId)\n              .sort((a, b) => (a.start_time < b.start_time ? 1 : -1))[0];\n            setSession(s ?? null);\n            return;\n          }\n          const data = await resp.json();\n          const msgs = data.messages || [];\n          const mapped: Session = {\n            session_id: activeThreadId,\n            thread_id: activeThreadId,\n            start_time: new Date().toISOString(),\n            detected_mode: 'reflective',\n            confidence_score: 0.5,\n            messages: msgs.map((m: any) => ({ role: m.role === 'assistant' ? 'assistant' : 'user', content: m.content, timestamp: m.ts || m.created_at })),\n          };\n          setSession(mapped);\n        } catch (e) {\n          const s: Session | undefined = [...sessions]\n            .filter((s) => s.thread_id === activeThreadId)\n            .sort((a, b) => (a.start_time < b.start_time ? 1 : -1))[0];\n          setSession(s ?? null);\n        }\n      })();\n    } catch (e) {\n      setSession(null);\n    }\n\n    return () => { mounted = false; };\n  }, [activeThreadId]);\n\n  return { session };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}